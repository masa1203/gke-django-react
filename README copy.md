# GKE に Django-React をデプロイする

## 目標

Docker 環境下で Django と React を連携させて Google Kubernetes Engine にデプロイしてポートフォリオを作りたい。

## 環境

Docker - Google Cloud Registry
Kubernetes - Google Kubenetes Engine
Django - Python
React - Javascript
CI/CD - Cloud Function

開発は Windows10 home で Docker Toolbox を使用しています。

## まずはローカルで始める

まずはローカルで Django と React の連携を ToDO アプリを作成しながら考えてみます。

### ディレクトリを作成する

Docker Toolbox は Virtualbox を使って docker ホストを立てます。
コンテナのボリュームのマウントは`C:Users/`環境下がデフォルトで設定されているので、
Docker toolbox を使用する場合は User ディレクトリ下をおススメします。

```sh
# プロジェクトフォルダの作成
mkdir gke-django
cd gke-djagno
# ディレクトリを作成する
mkdir backend
mkdir frontend
```

### Backend の開発を進める

backend は Django-rest-framework で API を作成します。
まずは backend から環境を作成してみます。

#### settings.py

```sh
cd backend
# 仮想環境の作成
python -m venv venv
# 仮想環境の有効化
venv\Scripts\activate
# Pythonパッケージのインストール
python -m pip install --upgrade pip setuptools
python -m pip install django djangorestframework python-dotenv
# Djangoのプロジェクトを始める。
django-admin startproject config .
```

backend ディレクトリ下で`django-admin startproject config .`とすることで、
`backend`下に`config`というプロジェクトフォルダが作成されました。

config/settings.py を編集していきます。
まずは基本的なことだけ編集します。
SECRET_KEY は.env に追記するのでコピーしておきましょう。

```python
# config/settings.py

"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 3.0.4.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.0/ref/settings/
"""

import os
from dotenv import load_dotenv  # 追加

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PROJECT_DIR = os.path.basename(BASE_DIR)

# .envの読み込み
load_dotenv(os.path.join(BASE_DIR, '.env'))  # 追加

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],  # 変更
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'


# Database
# https://docs.djangoproject.com/en/3.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}


# Password validation
# https://docs.djangoproject.com/en/3.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/3.0/topics/i18n/

LANGUAGE_CODE = 'ja'

TIME_ZONE = 'Asia/Tokyo'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.0/howto/static-files/

STATIC_URL = '/static/'

# 開発環境下で静的ファイルを参照する先
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

# 本番環境で静的ファイルを参照する先
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# メディアファイルpath
MEDIA_URL = '/media/''
```

settings.py 内で参照している`.env`を作成します。

```sh
# .envファイルの作成
type nul > .env

# .envにコピペしておいたSECRET_KEYを追加する
SECRET_KEY = '+_f1u^*rb8+%cn-4o*kjn_(15*wspz0*!c)@=ll08odexo88a4'
```

#### todo アプリを始める

```sh
python manage.py startapp todos
```

settings.py にアプリケーションを追加します。

```python
# conig/settings.py

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'todos.app.TodosConfig'  # 追加
]
```

model をつくって migration して admin に登録します。

```python
# todos/models.py
from django.db import models


class Todo(models.Model):
    title = models.CharField(max_length=200)
    body = models.TextField()

    def __str__(self):
        return self.title
```

```sh
$ python manage.py makemigrations todos
Migrations for 'todos':
  todos\migrations\0001_initial.py
    - Create model Todo

$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions, todos
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying sessions.0001_initial... OK
  Applying todos.0001_initial... OK
```

```python
# todos/admin.py
from django.contrib import admin
from .models import Todo


admin.site.register(Todo)
```

管理ユーザーを作成して admin にログインして todo を 3 つほど登録します。

```sh
$ python manage.py createsuperuser
ユーザー名 (leave blank to use 'yourname'): yourname
メールアドレス: youraddress@mail.com
Password:
Password (again):
Superuser created successfully.

$ python manage.py runserver
Watching for file changes with StatReloader
Performing system checks...

System check identified no issues (0 silenced).
March 10, 2020 - 23:41:26
Django version 3.0.4, using settings 'config.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CTRL-BREAK.

```

`http://127.0.0.1:8000/admin`にアクセスすると django-admin のログインページが開かれるので
createsuperuser で登録した内容でログインしてみましょう。
Todos を 3 つほど登録しておきましょう。

#### djangorestframework をはじめる

最初に`pip`でインストールした`restframework`を使用できるように config/settings.py を更新します。

```python
# config/settings.py

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # 3rd party
    'rest_framework',

    # Local
    'todos.apps.TodosConfig',
]

# 追加
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ]
}

```

`rest_framework.permissions.AllowAny`は django-rest-framework が暗黙的に決めているデフォルトの設定`'DEFAULT_PERMISSION_CLASSES'`を解除するためのものです。
この設定はまだよくわかってないのですがとりあえず前に進みます。

`todos/urls.py`, `todos/views.py`, `todos/serializers.py`を作成します。

##### URLs

`config/urls.py`から各アプリケーションの`urls.py`を追加します。

```python
# config/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('todos.urls'))
]

```

`todos/urls.py`を追加します。

```sh
$ type nul > todos\urls.py
```

```python
# todos/urls.py
from django.urls import path
from .views import ListTodo, DetailTodo

urlpatterns = [
    path('<int:pk>/', DetailTodo.as_view()),
    path('', ListTodo.as_view())
]
```

##### Selializers

モデルインスタンスを json 形式へ変換するための`serializers.py`を追加します。

```sh
type nul > todos\serializers.py
```

```python
# todos/serializers.py
from rest_framework import serializers
from .models import Todo


class TodoSerializer(serializers.ModelSerializer):
    class Meta:
        model = Todo
        fields = ('id', 'title', 'body')
```

`fields = ('id', 'title', 'text')`での`id`は PrimaryKey を指定しない場合、
Django によって自動的に追加されます。

##### Views

Django Rest Framework で`views.py`を作成する場合は`rest_framework.generics`の APIView を継承します。

```python
# todos/views.py

from django.shortcuts import render
from rest_framework import generics
from .models import Todo
from .serializers import TodoSerializer


class ListTodo(generics.ListAPIView):
    queryset = Todo.objects.all()
    serializer_class = TodoSerializer


class DetailTodo(generics.RetrieveAPIView):
    queryset = Todo.objects.all()
    serializer_class = TodoSerializer
```

router など設定できていませんが、とりあえずは Todo アイテムを API として使用できるようになりました。
開発サーバーで`http://127.0.0.1:8000/api/`にアクセスすると APIview を確認することができます。

ここまでは Django でよくあるローカル環境での開発です。

##### CORS

CORS(Cross-Origin Resource Sharing)は React と Django を連携させる場合、
React を起動した`localhost:3000`は Django の API サーバー`localhost:8000`と
json のやり取りを行わせるためのものです。
`django-cors-headers`をインストールしましょう。

```sh
python -m pip install django-cors-headers
```

`config/settings.py`を更新します。

```python
# config/settings.py

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # 3rd party
    'rest_framework',
    'corsheaders',

    # Local
    'todos.apps.TodosConfig',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',  # 追加
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

##################
# rest_framework #
##################

REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ]
}

CORS_ORIGIN_WHITELIST = (
    'http://localhost:3000',
)
```

##### Tests

テストを書きます。

```python
# todos/test.py

from django.test import TestCase
from .models import Todo


class TodoModelTest(TestCase):

    @classmethod
    def setUpTestData(cls):
        Todo.objects.create(title="first todo", body="a body here")

    def test_title_content(self):
        todo = Todo.objects.get(id=1)
        excepted_object_name = f'{todo.title}'
        self.assertEqual(excepted_object_name, 'first todo')

    def test_body_content(self):
        todo = Todo.objects.get(id=1)
        excepted_object_name = f'{todo.body}'
        self.assertEqual(excepted_object_name, 'a body here')

```

```sh
$ python manage.py test
Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..
----------------------------------------------------------------------
Ran 2 tests in 0.007s

OK
Destroying test database for alias 'default'...
```

うまくいったようです。

### Frontend の開発を進める

Nodejs は予めインストールしておきましょう。

```sh
$ cd frontend
$ npx create-react-app .
$ yarn start

yarn run v1.22.0
$ react-scripts start
i ｢wds｣: Project is running at http://192.168.56.1/
i ｢wds｣: webpack output is served from
i ｢wds｣: Content not from webpack is served from
C:\--you-path--\gke-django-tutorial\frontend\public
i ｢wds｣: 404s will fallback to /
Starting the development server...
Compiled successfully!

You can now view frontend in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://192.168.56.1:3000

Note that the development build is not optimized.
To create a production build, use yarn build.

```

フロントエンドのプロジェクトを React で開始することができました。
ブウラウザーで`http://localhost:3000`にアクセスすると React の Welcome ページが確認できます。

#### App.js

api のエンドポイントは以下のような形で api を返してくるので、これを意識しておきましょう。
まずは mock となるデータで試してみます。

```json
[
  {
    "id": 1,
    "title": "test_title",
    "body": "body of test_title"
  },
  {
    "id": 2,
    "title": "test_title2",
    "body": "body of test_title2"
  },
  {
    "id": 3,
    "title": "test_title3",
    "body": "body of test_title3"
  }
]
```

```javascript
// src/App.js

import React, { Component } from "react";
import axios from "axiso";
import "./App.css";

const list = [
  {
    id: 1,
    title: "test_title",
    body: "body of test_title"
  },
  {
    id: 2,
    title: "test_title2",
    body: "body of test_title2"
  },
  {
    id: 3,
    title: "test_title3",
    body: "body of test_title3"
  }
];

class App extends Component {
  constructor(props) {
    super(props);
    this.state = { list };
  }

  render() {
    return (
      <div>
        {this.state.list.map(item => (
          <div key={item.id}>
            <h1>{item.title}</h1>
            <p>{item.body}</p>
          </div>
        ))}
      </div>
    );
  }
}

export default App;
```

`http://localhost:3000`にアクセスするとモックデータが表示されました。
これを `backend`から取得したデータで表示させたいです。

#### axios

frontend でリクエストを叩くには build-in の `Fetch API` か `axios` を使う方法がありますが、
今回は `axios` を使うことにします。

```sh
npm install axios --save
yarn start
```

App.js を書き換えます。

```javascript
// src/App.js

import React, { Component } from "react";
import axios from "axios";
import "./App.css";

class App extends Component {
  state = {
    todos: []
  };

  componentDidMount() {
    this.getTodos();
  }

  getTodos() {
    axios
      .get("http://127.0.0.1:8000/api/")
      .then(res => {
        this.setState({ todos: res.data });
      })
      .catch(err => {
        console.log(err);
      });
  }

  render() {
    return (
      <div>
        {this.state.todos.map(item => (
          <div key={item.id}>
            <h1>{item.title}</h1>
            <p>{item.body}</p>
          </div>
        ))}
      </div>
    );
  }
}

export default App;
```

これでローカル環境で frontend から backend へ api をたたいて todo リスト一覧を表示させることができました。

超超単純な形ですが一応は Django と React の連携が取れました。

次はこれを Docker 化していきたいと思います。

## Docker 化を進める

frontend, backend それぞれに Dockerfile を作成して backend コンテナ、frontend コンテナを作成してみます。

まずは Docker-compose で立ち上げられるところまでを考えていきます。

### Backend の Docker 化

Dockerfile を書く前に Django 側でやっておきたいことがいくつかあります。

```sh
# 静的ファイ用のディレクトリ
$ mkdir backend\static
# 静的ファイルを全部集めてstaticifilesディレクトリに集められ
$ python manage.py collectstatic
```

本来であればデータベースの内容や settings.py を local と production で分けたりしますが、
まずは現在の形をそのまま Docker 化できることを考えます。

Dockerfile を backend ディレクトリ内に作成します。

```sh
$ type nul > backend\Dockerfile
```

```Dockerfile
# backend/Dockerfile

# set base image
FROM python:3.7

# set environment variables
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# set work directory
RUN mkdir /code
WORKDIR /code

# install dependencies
COPY requirements.txt /code/
RUN python3 -m pip install --upgrade pip setuptools
RUN pip install -r requirements.txt

# Copy project
COPY . /code/

EXPOSE 8000

```

次にプロジェクトディレクトリに docker-compose.yml を設置して
docker-compose up で backend コンテナを起動できるようにしてます。

```yaml
# docker-compose.yml
version: "3.7"

services:
  backend:
    build: ./backend/.
    command: python /code/manage.py runserver 0.0.0.0:8000
    volumes:
      - ./backend:/code
    ports:
      - "8000:8000"
```

```sh
$ docker-compose up
```

これで`http://localhost:8000/api/`にアクセスすると backend コンテナの DRF ビューにアクセスすることができました。
DockerToolbox を使っている場合は docker ホストの IP アドレスでアクセスしてください。

### Frontend の Docker 化

続いて frontend 側を Docker 化していきます。

参考 URL
Dockerizing a React App:
https://mherman.org/blog/dockerizing-a-react-app/

Creating an app with Docker Compose, Django, and Create React App:
https://dev.to/englishcraig/creating-an-app-with-docker-compose-django-and-create-react-app-31lf

Using Docker for Node.js in Development and Production:
https://dev.to/alex_barashkov/using-docker-for-nodejs-in-development-and-production-3cgp

frontend は React で構築しています。これを Docker 化するにはどうしたら良いでしょうか。
backend と同じように frontend ディレクトリに Dockerfile を作成します。

```sh
type nul > frontend\Dockerfile
```

```Dockerfile
# frontend/Dockerfile
FROM node:12.2.0-alpine

RUN mkdir /code
WORKDIR /code

# Install dependencies
COPY package.json /code/
COPY package-lock.json /code/
RUN npm install

# Add rest of the client code
COPY . /code/

EXPOSE 3000

```

これで node コンテナ内に package.json を使って同じ環境を構築することができます。
docker-compose.yml に frontend サービスを追加します。

```yml
# docker-compose.yml
version: "3.7"

services:
  backend:
    build: ./backend/.
    volumes:
      - ./backend:/code
    ports:
      - "8000:8000"
    stdin_open: true
    tty: true
    command: python /code/manage.py runserver 0.0.0.0:8000
    environment:
      - CHOKIDAR_USEPOLLING=true
  frontend:
    build: ./frontend/.
    volumes:
      - ./frontend:/code
      - /code/node_modules
    ports:
      - "3000:3000"
    command: npm start
    stdin_open: true
    tty: true
    environment:
      - CHOKIDAR_USEPOLLING=true
      - NODE_ENV=development
    depends_on:
      - backend
```

environment に`CHOKIDAR_USEPOLLING=true`を追加することでイメージを再ビルドすることなく
ホットリローディングしてくれるようになります。

frontend に関しては node_modules が巨大であるため、これをマウントしたりコピーしたりすると
かなりの時間を要します。
したがって、.dockerignore を追加して node_modules をイメージビルドに使用しないようにしておきます(あってる？)。

```sh
$ type nul > frontend\.dockerignore
```

```.dockerignore
/node_modules
```

### docker-compose up する前に

これで docker-compose up する準備が整いました、が、docker-toolbox を使っている場合は
ポートフォワーディングしているホスト名が`localhost`ではありません。これをホスト IP に書き換える必要があります。
`docker-machine ls` コマンドを使って使用しているホスト IP を確認します。

#### backend/settings.py

手元のブラウザから frontend コンテナ ⇒backend コンテナにアクセスするため、
`CORS_ORIGIN_WHITELIST`に docker ホスト IP を追加する必要があります。

```python
# backend/settings.py

CORS_ORIGIN_WHITELIST = (
    'http://localhost:3000',
    'http://192.168.99.100:3000',  # 追加
)
```

#### frontend/src/App.js

api のエンドポイントは docker ホスト IP になります。ここでは`192.168.99.100:8000`としています。

```javascript
// src/App.js

import React, { Component } from "react";
import axios from "axios";
import "./App.css";

class App extends Component {
  state = {
    todos: []
  };

  componentDidMount() {
    this.getTodos();
  }

  getTodos() {
    axios
      .get("http://192.168.99.100:8000/api/") //変更
      .then(res => {
        this.setState({ todos: res.data });
      })
      .catch(err => {
        console.log(err);
      });
  }

  render() {
    return (
      <div>
        <h1>mother fucker!!?? </h1>
        {this.state.todos.map(item => (
          <div key={item.id}>
            <h1>{item.title}</h1>
            <p>{item.body}</p>
          </div>
        ))}
      </div>
    );
  }
}

export default App;
```

### docker-compose up

docker-compose.yml のあるディレクトリ下で docker-compose up します。

```sh
$ docker-compose up --build
```

React のコンパイル完了には時間がかかります。

起動できたら`http://localhost:3000`にアクセスするとローカルで表示されていた内容が
再現されているはずです。

## Kubernetes へ

参考:
Running Django on Google Kubernetes Engine:
https://cloud.google.com/python/django/kubernetes-engine

GKE のチュートリアルを参考にして GKE にデプロイしていきます。先は長い。

### Before you begin

#### プロジェクトの作成

プロジェクト名：gke-django-react
場所：組織なし

#### 課金が有効かどうか確認する

参考 : https://cloud.google.com/billing/docs/how-to/modify-project?authuser=2

#### Cloud SDK をインストールして初期化する

```sh
$ gcloud init

Welcome! This command will take you through the configuration of gcloud.

Settings from your current configuration [kubeforpro] are:
accessibility:
  screen_reader: 'true'
core:
  account: komedapeople@gmail.com
  disable_usage_reporting: 'True'
  project: docker-book-new

Pick configuration to use:
 [1] Re-initialize this configuration [kubeforpro] with new settings
 [2] Create a new configuration
 [3] Switch to and re-initialize existing configuration: [default]
Please enter your numeric choice:2

Enter configuration name. Names start with a lower case letter and
contain only lower case letters a-z, digits 0-9, and hyphens '-':  gke-django-react

Your current configuration has been set to: [gke-django-react]

You can skip diagnostics next time by using the following flag:
  gcloud init --skip-diagnostics

Network diagnostic detects and fixes local network connection issues.

Choose the account you would like to use to perform operations for
this configuration:
 [1] ---------@gmail.com
 [2] Log in with a new account
Please enter your numeric choice: 1

Pick cloud project to use:
 [1] gke-django-react
 [2] Create a new project
Please enter numeric choice or text value (must exactly match list
item):  1

Your current project has been set to: [gke-django-react].

Not setting default zone/region (this feature makes it easier to use
[gcloud compute] by setting an appropriate default value for the
--zone and --region flag).
See https://cloud.google.com/compute/docs/gcloud-compute section on how to set
default compute region and zone manually. If you would like [gcloud init] to be
able to do this for you the next time you run it, make sure the
Compute Engine API is enabled for your project on the
https://console.developers.google.com/apis page.

Your Google Cloud SDK is configured and ready to use!

* Commands that require authentication will use komedapeople@gmail.com by default
* Commands will reference project `gke-django-react` by default
Run `gcloud help config` to learn how to change individual settings

This gcloud configuration is called [gke-django-react]. You can create additional configurations if you work with multiple accounts and/or projects.
Run `gcloud topic configurations` to learn more.

Some things to try next:

* Run `gcloud --help` to see the Cloud Platform services you can interact with. And run `gcloud help COMMAND` to get help on any gcloud command.
* Run `gcloud topic --help` to learn about advanced features of the SDK like arg files and output formatting

```

#### 必要な API を有効にする。

Datastore, Pub/Sub, Cloud Storage JSON, Cloud Logging, and Google+APIs を有効にします。

### Cloud SQL の準備

Cloud SQL Admin API を有効にします。

```sh
$ gcloud services enable sqladmin
Operation "operations/acf.f710abec-50e3-41ee-907f-f8f20098fe9b" finished successfully.
```

Cloud SQL Proxy をダウンロードして`cloud_sql_proxy.exe`に名前を変更します。

Cloud SQL インスタンス(PostgreSQL)を作成します。

```sh
インスタンスID:django-sql
デフォルトのユーザーパスワード:django-sql-pass
```

先ほどダウンロードした`cloud_sql_proxy.exe`を使って
Cloud SQL に接続するための`connectionName`を確認する。

```sh
gcloud sql instances describe django-sql

...
connectionName: gke-django-react:asia-northeast1:django-sql
...

```

この`connectionName`は`[PROJECT_NAME:REGION_NAME:INSTANCE]`で構成される。

### Cloud SQL の初期化

```sh
cloud_sql_proxy.exe -instances="gke-django-react:asia-northeast1:django-sql"=tcp:5432

2020/03/22 23:13:28 Listening on 127.0.0.1:5432 for gke-django-react:asia-northeast1:django-sql
2020/03/22 23:13:28 Ready for new connections
```

このコマンドによって local 環境から Cloud SQL インスタンスに接続することができます。
local 環境でテストする場合などは Cloud SQL Proxy を走らせておきましょう。

Cloud SQL インスタンスにデータベースを作成しておきましょう。
この作業は Cloud コンソールから行いました。

```sh
database : django-react-db
```

Cloud SQL のサービスアカウントを作成して json 形式のプライベートキーをダウンロードしましょう。

作成したインスタンス django-sql にユーザーアカウントを作成しておきましょう。

```sh
ユーザー名:master
パスワード:master-pass
```

#### django 側の設定変更

ここまで django 側のデータベースはデフォルトの db.sqlite3 を使用していました。
これを CloudSQL で使用できるように変更していきましょう。

```python
# backend/config/setting.sy

DATABASES = {
    'default': {
        # If you are using Cloud SQL for MySQL rather than PostgreSQL, set
        # 'ENGINE': 'django.db.backends.mysql' instead of the following.
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'django-react-db',
        'USER': os.getenv('DATABASE_USER'),
        'PASSWORD': os.getenv('DATABASE_PASSWORD'),
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```

```sh
# backend/.env
SECRET_KEY = '+_f1u^*rb8+%cn-4o*kjn_(15*wspz0*!c)@=ll08odexo88a4'
DATABASE_USER = master
DATABASE_PASSWORD = master-pass
```

仮想環境下で足りないパッケージを追加します。

```sh
$ python -m pip install wheel gunicorn psycopg2-binary

Collecting wheel
  Downloading wheel-0.34.2-py2.py3-none-any.whl (26 kB)
Collecting gunicorn
  Downloading gunicorn-20.0.4-py2.py3-none-any.whl (77 kB)
     |████████████████████████████████| 77 kB 563 kB/s
Collecting psycopg2-binary
  Downloading psycopg2_binary-2.8.4-cp37-cp37m-win_amd64.whl (1.1 MB)
     |████████████████████████████████| 1.1 MB 1.1 MB/s
Requirement already satisfied: setuptools>=3.0 in c:\----\gke-django-tutorial\backend\venv\lib\site-packages (from gunicorn) (45.3.0)
Installing collected packages: wheel, gunicorn, psycopg2-binary
Successfully installed gunicorn-20.0.4 psycopg2-binary-2.8.4 wheel-0.34.2

```

requirements.txt を更新します。

```sh
$ python -m pip freeze > requirements.txt
```

データベースが新しくなったので改めてマイグレーションする必要があります。

```sh
$ python manage.py makemigrations
No changes detected

$ python manage.py migrate
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions, todos
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying sessions.0001_initial... OK
  Applying todos.0001_initial... OK
```

無事に CloudSQL にマイグレーションすることができました。問題なくデータベースは使えているようです。
管理ユーザーを作成しましょう。

```sh
$ python manage.py createsuperuser

ユーザー名 (leave blank to use 'yourname'):
メールアドレス: ---------@gmail.com
Password:
Password (again):
Superuser created successfully.
```

開発用サーバーを立ち上げて admin にアクセスしてデータを 3 つほど入れておく。

```sh
$ python manage.py runserver
```

### settings for GCS

静的ファイルを Google Cloud Strage に格納するための設定を行います。

```sh
# ストレージの作成
gsutil mb gs://gke-django-storage

# 公開設定
gsutil defacl set public-read gs://gke-django-storage

# 静的ファイルを集める
python manage.py collectstatic

# Cloud Storageに静的ファイルをアップロードする
gsutil rsync -R static/ gs://gke-django-storage/static
```

`backend/config//settings.py`の`STATIC_URL`を変更する。

```python
# backend/config/settings.py
STATIC_URL = 'https://storage.googleapis.com/gke-django-storage/static/'
```

### setting GKE configuration

#### クラスター作成

GKE の API を有効にして、GKE クラスターを作成する。

```sh
# クラスタ：gke-django-react
$ gcloud container clusters create gke-django-react --scopes "https://www.googleapis.com/auth/userinfo.email","cloud-platform" --num-nodes 4 --zone "us-central1-a"
```

作成したクラスターを kubectl から利用するために contexts を入手する

```sh
$ gcloud container clusters get-credentials gke-django-react --zone="us-central1-a"
```

コンテキストが適用されているかどうかを確認する。

```sh
$ kubectl config current-context
gke_gke-django-react_us-central1-a_gke-django-react
```

#### Cloud SQL の設定

GKE から Cloud SQL のインスタンスを使用するにあたって、インスタンスの接続とデータベースのアクセスに関する
secrets を作成する必要がある。

インスタンスレベルのアクセスについて secret を作成する。

```sh
$ kubectl create secret generic cloudsql-oauth-credentials --from-file=credentials.json=".\secrets\cloudsql\gke-django-react-9e0e7c359eb3.json"

secret/cloudsql-oauth-credentials created
```

データベースへのアクセスについて secret を作成する。

```sh
$ kubectl create secret generic cloudsql --from-literal=username="master" --from-literal=password="master-pass"
```

Cloud SQL proxy の Docker image を入手する。

```sh
$ docker pull b.gcr.io/cloudsql-docker/gce-proxy
```

#### コンテナイメージの用意

ローカルでイメージをビルドしてから Google Cloud Registry にアップロードする。

```sh
$ docker image build --no-cache -t gke-django-backend ./backend
$ docker image build --no-cache -t gke-django-frontend ./frontend
```

docker イメージ名を変更して Cloud Registry にアップロードする。
イメージ名は`gcr.io/${PROJECT}/${IMAGENAME}:${TAGNAME}`のフォーマットにする必要がある。

```sh
# Project名の取得
$ gcloud config get-value project

Your active configuration is: [gke-django-react]
gke-django-react

# タグ名の変更: backend
$ docker tag gke-django-backend:latest gcr.io/gke-django-react/backend:v1

# タグ名の変更: frontend
$ docker tag gke-django-frontend:latest gcr.io/gke-django-react/frontend:v1

# イメージをGCRにアップロードする
$ gcloud docker -- push gcr.io/gke-django-react/backend

WARNING: `gcloud docker` will not be supported for Docker client versions above 18.03.

As an alternative, use `gcloud auth configure-docker` to configure `docker` to
use `gcloud` as a credential helper, then use `docker` as you would for non-GCR
registries, e.g. `docker pull gcr.io/project-id/my-image`. Add
`--verbosity=error` to silence this warning: `gcloud docker
--verbosity=error -- pull gcr.io/project-id/my-image`.

See: https://cloud.google.com/container-registry/docs/support/deprecation-notices#gcloud-docker

The push refers to repository [gcr.io/gke-django-react/backend]
53b45a7883b7: Pushed
dc63d744f1ce: Pushed
03bc31182b66: Pushed
2ba1adb685cc: Pushed
512c6383c11e: Pushed
7b467e610997: Layer already exists
72e018dfb28d: Layer already exists
a6b1c5949826: Layer already exists
3dffd131f01f: Layer already exists
271910c4c150: Layer already exists
6670e930ed33: Layer already exists
c7f27a4eb870: Layer already exists
e70dfb4c3a48: Layer already exists
1c76bd0dc325: Layer already exists
v1: digest: sha256:67638f2f44019ec520037fd85ef91c2a2fd52b3396a8b4964dc5c54e208bbed1 size: 3267

$ gcloud docker -- push gcr.io/gke-django-react/frontend

WARNING: `gcloud docker` will not be supported for Docker client versions above 18.03.

As an alternative, use `gcloud auth configure-docker` to configure `docker` to
use `gcloud` as a credential helper, then use `docker` as you would for non-GCR
registries, e.g. `docker pull gcr.io/project-id/my-image`. Add
`--verbosity=error` to silence this warning: `gcloud docker
--verbosity=error -- pull gcr.io/project-id/my-image`.

See: https://cloud.google.com/container-registry/docs/support/deprecation-notices#gcloud-docker

The push refers to repository [gcr.io/gke-django-react/frontend]
7ce3a1d19f5a: Pushed
f57295790b0a: Pushed
9cf8533fdf66: Pushed
ae1413e62a19: Pushed
af340b47669f: Pushed
917da41f96aa: Pushed
7d6e2801765d: Pushed
f1b5933fe4b5: Layer already exists
v1: digest: sha256:f47dadd27f0912a1b86450b0f952c9035b4e14c3e558c704fa7f8c5bfa9d3c5e size: 1997
```

#### Frontend のデプロイ

Frontend の Development を作成してデプロイします。
frontend-react.yml を作成します。

```sh
$ type nul > frontend-react.yml
```

```yml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: frontend
  namespace: default
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
        - name: frontend
          image: gcr.io/gke-django-react/frontend:v1
          imagePullPolicy: Always
```

```sh
$ kubectl create -f frontend-react.yml
deployment.extensions/frontend created

$ kubectl get pods
NAME                        READY   STATUS              RESTARTS   AGE
frontend-6d64b99848-b554z   0/1     ContainerCreating   0          11s
frontend-6d64b99848-gcqm2   0/1     ContainerCreating   0          11s
frontend-6d64b99848-gtbk2   0/1     ContainerCreating   0          11s
```

#### Backend のデプロイ

Backend の Development を作成してデプロイします。
backend-django.yml を作成します。

```sh
type nul > backend-django.yml
```

```yml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: backend
  namespace: default
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
        - name: backend
          image: gcr.io/gke-django-react/backend:v1
          imagePullPolicy: Always
          env:
            - name: DATABASE_USER
              valueFrom:
                secretKeyRef:
                  name: cloudsql
                  key: username
            - name: DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: cloudsql
                  key: password
          ports:
            - containerPort: 8000

        - image: gcr.io/cloudsql-docker/gce-proxy:1.16
          name: cloudsql-proxy
          command:
            [
              "/cloud_sql_proxy",
              "--dir=/cloudsql",
              "-instances=gke-django-react:asia-northeast1:django-sql=tcp:5432",
              "-credential_file=/secrets/cloudsql/credentials.json",
            ]
          volumeMounts:
            - name: cloudsql-oauth-credentials
              mountPath: /secrets/cloudsql
              readOnly: true
            - name: ssl-certs
              mountPath: /etc/ssl/certs
            - name: cloudsql
              mountPath: /cloudsql
      volumes:
        - name: cloudsql-oauth-credentials
          secret:
            secretName: cloudsql-oauth-credentials
        - name: ssl-certs
          hostPath:
            path: /etc/ssl/certs
        - name: cloudsql
          emptyDir:

```

backendはdjangoとCloud SQLを利用するためのproxyコンテナが一緒のpodに配置されています。

```sh
$ kubectl create -f backend-django.yml
```

```sh
$ kubectl get pods
NAME                        READY   STATUS             RESTARTS   AGE
backend-6d76f8b68b-gc472    1/2     CrashLoopBackOff   1          52s
backend-6d76f8b68b-jfnxj    1/2     CrashLoopBackOff   1          52s
backend-6d76f8b68b-pnpfg    1/2     CrashLoopBackOff   1          52s
frontend-6d64b99848-b554z   0/1     CrashLoopBackOff   21         86m
frontend-6d64b99848-gcqm2   0/1     CrashLoopBackOff   21         86m
frontend-6d64b99848-gtbk2   0/1     CrashLoopBackOff   21         86m
```

#### Ingress

ネットワークを構築してアプリケーションとして機能させます。

ネットワークを定義する前に

```sh
$ kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user komedapeople@gmail.com

$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml

$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/cloud-generic.yaml

$
